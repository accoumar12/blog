---
title: My git workflow
date: 2025-11-07
description: My git workflow for organizing and managing code changes effectively.
tags:
  - learning
  - git
  - productivity
---

> **TL;DR:**
> - ğŸ’» Use Git CLI over GUI tools for deeper understanding and flexibility.
> - âš¡ Leverage terminal aliases to speed up common operations.
> - ğŸŒ³ Use git worktrees when actually needed.
> - ğŸš« Never use stashes for meaningful workâ€”use branches instead.
> - ğŸ“¦ Adopt squash merging with a PR-based workflow.
> - âœ¨ Don't obsess over commit history during developmentâ€”clean it up later.

[Git](https://git-scm.com/) is a fundamental tool for any developer. Over time, I've seen many different workflows and strategies, and I've noticed that bad habits can waste significant time. This article lays out my approach to using Git effectively.

I'm particularly frustrated by the amount of poor Git advice online. A classic example: using `git stash` to temporarily save work when switching branches. This is problematic because stashes are easy to forget and you lose track of context. I'll explain a better approach below.

## ğŸ’» Use Git CLI as Your Primary Tool

Many developers rely heavily on visual interfaces for every Git operation, including adding and committing. This isn't ideal because:

- **ğŸ› GUI Bugs:** Visual tools can have bugs (looking at you, [Sublime Merge](https://www.sublimemerge.com/)).
- **ğŸ­ Abstraction Layer:** GUIs just run CLI commands under the hood anyway.
- **ğŸ“š Deeper Understanding:** Using the CLI helps you truly understand Git.
- **ğŸ”§ More Power:** CLI gives access to powerful customizations and aliases.

That said, visual tools have their place. I use VSCode's interface for merge conflicts and the [Git Graph](https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph) extension for deep history exploration. For quick lookups, `git log` is sufficient.

## âš¡ Use Terminal Aliases to Speed Up Your Workflow

**Objection:** "But typing `git add` and `git commit -m` every time is so slow! GUIs are faster!"

**Solution:** Use Git aliases. I highly recommend the [zsh git plugin](https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git).

My most-used aliases:

- **`gac`** = `git add -A; git commit -m "$1"` â€” Add all changes and commit with a message.
- **`gst`** = `git status` â€” Show Git status.
- **`gwip`** = Work-in-progress commit â€” Adds everything and commits with `--wip-- [skip ci]`. This is **much better than `git stash`**. How many times have you forgotten to reapply a stash? Plus, the `[skip ci]` pattern is recognized by most CI systems (like GitHub) and skips unnecessary builds.

## âš™ï¸ Configure Git Properly with .gitconfig

Git's defaults aren't optimal. Take inspiration from [how Git core developers configure Git](https://blog.gitbutler.com/how-git-core-devs-configure-git). Feel free to check out my [.gitconfig](https://github.com/accoumar12/dotfiles/blob/main/.gitconfig) for ideas!

## ğŸŒ³ Use Git Worktrees When Actually Needed

I used to default to using git worktrees for everything. However, I've learned that some repositories implicitly assume a single working directory (e.g., to retrieve the current git hash). Now I default to a single working directory and only use git worktrees when I genuinely need multiple branches checked out simultaneously.

There's actually a nice workflow I follow when using git worktrees, which I explain in detail in [this article](https://maccou-blog.netlify.app/why-i-use-git-worktrees/).

## ğŸš« Never Use Stashes for Meaningful Work

Need to switch branches while developing a feature? **Do not use stashes**, even with meaningful names. Use branches insteadâ€”that's what they're for!

Stashes are the best way to lose important information. Git allows unlimited branches, so use them liberally!

I tend to use a lot my `gwip` alias to create quick WIP commits. When switching back to the feature branch, I can amend the WIP commit (if really needed) or squash it later.

## ğŸ”€ Adopt a Clear Branching Strategy

I favor a **PR-based workflow**:

- **ğŸ”’ Protected Main Branch:** Direct commits to `main` are forbidden.
- **ğŸŒ¿ Feature Branches:** Create branches from `main` for each feature.
- **âœ… Pull Requests:** Open PRs to merge features back to `main`.
- **ğŸ¤– Continuous Integration:** CI runs on each PR before merging.
- **ğŸ“¦ Squash Merging:** Individual commits in feature branches don't matterâ€”they're squashed on merge.

Each PR should follow the [perfect commit](https://simonwillison.net/2022/Oct/29/the-perfect-commit/) rules: include implementation, tests, and documentation. For larger PRs or when there's an existing issue, I link the PR to the issue using [GitHub's linking feature](https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/linking-a-pull-request-to-an-issue). For smaller changes, a well-written PR description suffices. I also prefix PR titles with emojis to quickly convey the type of change: âœ¨ for features, ğŸ› for bug fixes, â™»ï¸ for refactors, etc.

## ğŸ¨ Don't Obsess Over Commit History During Development

Many developers waste time trying to maintain a perfect commit history from the start. In a squashed merge workflow, this is unnecessaryâ€”all commits get squashed when the PR merges.

Your development workflow should recognize two distinct phases:

### ğŸš§ Development Phase
Commit history is organizationalâ€”for you only. Be fuzzy and quick. Don't overthink it.

### âœ… Final Phase
When merging, I typically squash all commits since the PR should be small and focused enough to review as a single unit.

However, if you need to preserve a clean commit history within the branch before merging, use `git reset --soft <starting-commit-hash>` to unstage all commits back to your starting point, then carefully reconstruct them. Tools like VSCode or [magit](https://magit.vc/) make this easier by allowing you to stage specific chunks from files into individual commits.

## Conclusion

My Git workflow prioritizes:

- **ğŸ¯ Efficiency:** CLI with aliases beats GUI clicking.
- **ğŸ§¹ Cleanliness:** Squash merging keeps history clean.
- **ğŸ”„ Flexibility:** Branches over stashes.
- **ğŸ¨ Pragmatism:** Perfect commits at merge time, not during development.

Adopt these practices gradually and adjust to your needs. The goal is to make Git work for you, not against you.

Happy coding!